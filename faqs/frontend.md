# 前端存储方式，以及它们之间的优缺点。



# 移动端页面适配解决方案
我的回答是淘宝的flexible.js来做屏幕适配，然后面试官询问了它的实现原理，以及浏览器中几种长度单位（rem、em、px）的特点和区别，很可惜这块我答得不是很好，没有完全理清物理像素和逻辑像素的区别，面试官小哥哥也告诉我了解一个框架的实现原理比用一个框架更有意思，不是么？


# 图片懒加载如何实现
>https://juejin.im/post/5c9376506fb9a070fc623b2c

图片懒加载技术主要通过监听图片资源容器是否出现在视口区域内，来决定图片资源是否被加载。早前实现的思路：

给目标元素指定一张占位图，将真实的图片链接存储在自定义属性中，通常是data-src；
监听与用户滚动行为相关的 scroll 事件；
在 scroll 事件处理程序中利用 Element.getBoundingClientRect() 方法判断目标元素与视口的交叉状态；
当目标元素与视口的交叉状态大于0时，将真实的图片链接赋给目标元素 src 属性或者 backgroundImage 属性。


# 函数防抖、函数节流
>https://www.cnblogs.com/walls/p/6399837.html
>https://www.jianshu.com/p/c8b86b09daf0

频繁触发的事件：scroll, resize, mousemove

防抖（debounce）
所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
防抖函数分为非立即执行版和立即执行版。

函数节流是指一定时间内js方法只跑一次。比如人的眨眼睛，就是一定时间内眨一次。这是函数节流最形象的解释。
 函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有别人没刷卡了，司机才开车。

# 事件冒泡（事件传播）、事件捕获、事件代理（事件委托）
>https://www.cnblogs.com/moqing/p/5590216.html
>https://www.cnblogs.com/moqing/p/5590433.html
冒泡和捕获是两种相反的事件传播
冒泡从内到外、捕获从外到内

addEventListener的第三个参数，true捕获 或 false冒泡，默认是false

事件冒泡(事件传播)在元素的操作（比如点击）产生的事件，会传输给父级元素、再到父级元素、一直到document。
可以通过e.stopPropagation，停止传输

事件委托。
举例：ul元素中一堆li，如果给li绑定事件，要每个都绑定影响性能。
所以可以利用事件冒泡的原理，给父级绑定事件，然后通过事件触发的源头找到对应的li。
还有个好处，如果后期操作li，比如新增li，不需在对li特殊处理。


# addEventListener vs onXXX
addEventListener支持第三参数、设置成捕获、可以对统一事件增加多个回调函数、
onXXX会覆盖之前定义的函数，保留最后一个。


# 文件下载
>https://zhuanlan.zhihu.com/p/58888918